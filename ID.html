 <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
</body>
</html>

<button id="installPwaButton" style="display:none;">
  Instalar App
</button>

  <script>
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('/service-worker.js');
}

  </script>

<script type="text/javascript">
    (function(c,l,a,r,i,t,y){
        c[a]=c[a]||function(){(c[a].q=c[a].q||[]).push(arguments)};
        t=l.createElement(r);t.async=1;t.src="https://www.clarity.ms/tag/"+i;
        y=l.getElementsByTagName(r)[0];y.parentNode.insertBefore(t,y);
    })(window, document, "clarity", "script", "u88ounnzyq");
</script>

 <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.4/dist/jquery.min.js"></script>
</body>
</html>

<!-- Clarity tracking code for https://dmrede.loophole.site -->
<script>
    (function(c,l,a,r,i,t,y){
        c[a]=c[a]||function(){(c[a].q=c[a].q||[]).push(arguments)};
        t=l.createElement(r);t.async=1;t.src="https://www.clarity.ms/tag/"+i+"?ref=bwt";
        y=l.getElementsByTagName(r)[0];y.parentNode.insertBefore(t,y);
    })(window, document, "clarity", "script", "u88ounnzyq");
</script>

 <script src="https://cdnjs.cloudflare.com/ajax/libs/cpf-utils/2.0.1/cpf-utils.min.js"></script>
</body>
</html>

 <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.8/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>

 <script src="https://lucasok3555.github.io/Lucasweb/cdn.js"></script>
</body>
</html>

 <script src="http://dmrede.liveblog365.com/cdn.js"></script>
</body>
</html>

 <script src="https://lucasok3555.github.io/Lucasweb/cookie.js"></script>
</body>
</html>

 <script src="https://cdnjs.cloudflare.com/ajax/libs/basil.js/0.4.11/basil.min.js"></script>
</body>
</html>

 <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
</body>
</html>

 <script src="https://cdn.d3js.org/d3.v7.min.js"></script>
</body>
</html>

 <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
</body>
</html>

 <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
</body>
</html>

 <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
</body>
</html>

 <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
</body>
</html>

 <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.4/src/core.min.js"></script>
</body>
</html>

 <script src="/ID.js"></script>
</body>
</html>

<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-DQGCR653QQ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-DQGCR653QQ');
</script>

  <script src="https://lucasok3555.github.io/Lucasweb/cookie.js"></script>
</body>
</html>

<head>
    <title>aplicativo 100% brasileiro</title>
    <meta name="description" content="rede virtual do super aplicativo brasileiro">
</head>

<script 
 <scriptif ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('/service-worker.js');
}  </script>

<body>
  <script src="favicon.ico"></script>
</body>
</html>

<?php include 'registrarbot.php'; ?>
<!DOCTYPE html>
<html>

<?php include 'rrweb.php'; ?>
<!DOCTYPE html>
<html>

<link rel="manifest" href="/manifest.json">

<script>
// Uso:
const cacheManager = new CacheManager();

// Adicionar URLs ao cache
cacheManager.addToCache('/api/data');
cacheManager.addToCache('/images/banner.jpg');

// Buscar com cache
async function loadData() {
  const response = await cacheManager.fetchWithCache('/api/produtos');
  const data = await response.json();
  console.log(data);
}

// Limpar cache quando necessário
// cacheManager.clearCache();
</script>

<script>
  // Limpar cache
  async clearCache() {
    try {
      const deleted = await caches.delete(this.cacheName);
      console.log(`Cache ${this.cacheName} removido:`, deleted);
    } catch (error) {
      console.error('Erro ao limpar cache:', error);
    }
  }

  // Listar todos os itens em cache
  async listCachedItems() {
    try {
      const cache = await caches.open(this.cacheName);
      const requests = await cache.keys();
      return requests.map(req => req.url);
    } catch (error) {
      console.error('Erro ao listar itens do cache:', error);
      return [];
    }
  }
}
</script>

<script type="module">
  // Import the functions you need from the SDKs you need
  import { initializeApp } from "https://www.gstatic.com/firebasejs/12.3.0/firebase-app.js";
  import { getAnalytics } from "https://www.gstatic.com/firebasejs/12.3.0/firebase-analytics.js";
  // TODO: Add SDKs for Firebase products that you want to use
  // https://firebase.google.com/docs/web/setup#available-libraries

  // Your web app's Firebase configuration
  // For Firebase JS SDK v7.20.0 and later, measurementId is optional
  const firebaseConfig = {
    apiKey: "AIzaSyCeSCr1rO_CHlM214Q2ZtiBXUmv7E9Ib90",
    authDomain: "jjkhjk-5dcad.firebaseapp.com",
    projectId: "jjkhjk-5dcad",
    storageBucket: "jjkhjk-5dcad.firebasestorage.app",
    messagingSenderId: "927579447565",
    appId: "1:927579447565:web:aaaa4d42733381150b5044",
    measurementId: "G-FEFBT5RCTJ"
  };

  // Initialize Firebase
  const app = initializeApp(firebaseConfig);
  const analytics = getAnalytics(app);
</script>

<button id="installPwaButton" style="display:none;">
  Instalar App
</button>

<!DOCTYPE html>
<html ⚡>
  <head>
    <meta charset="utf-8" />
    <link rel="canonical" href="self.html" />
    <meta name="viewport" content="width=device-width" />
    <style amp-boilerplate>body{-webkit-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-moz-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-ms-animation:-amp-start 8s steps(1,end) 0s 1 normal both;animation:-amp-start 8s steps(1,end) 0s 1 normal both}@-webkit-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-moz-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-ms-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-o-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}</style><noscript><style amp-boilerplate>body{-webkit-animation:none;-moz-animation:none;-ms-animation:none;animation:none}</style></noscript>
    <script async src="https://cdn.ampproject.org/v0.js"></script>
    <script async custom-element="amp-base-carousel" src="https://cdn.ampproject.org/v0/amp-base-carousel-0.1.js"></script>
    <style amp-custom>
  </head>
  <body>
    <amp-base-carousel loop="true"  width="600" height="400" layout="responsive">
        <amp-img src="/favicon.ico" width="600" height="400" layout="responsive"></amp-img>
        <amp-img src="/favicon.ico" width="600" height="400" layout="responsive"></amp-img>
        <amp-img src="/favicon.ico" width="600" height="400" layout="responsive"></amp-img>
        <amp-img src="/favicon.ico" width="600" height="400" layout="responsive"></amp-img>
    </amp-base-carousel>
    </button>
  </body>
</html>



    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>

    <script src="https://unpkg.com/react@18.3.1/umd/react.production.min.js"></script>


    <script src="https://unpkg.com/preact@10.26.4/dist/preact.min.js"></script>


    <script src="https://cdn.statically.io/gh/lodash/lodash/4.17.15-npm/lodash.min.js"></script>



    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.4.5/angular.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.4.5/angular-sanitize.js"></script>

  <script>
    // Nome da chave para armazenar no localStorage
    const scrollKey = 'pageScrollPosition';

    // Restaurar posição ao carregar a página
    window.addEventListener('load', () => {
      const savedPosition = localStorage.getItem(scrollKey);
      if (savedPosition) {
        // Restaura a posição de rolagem
        window.scrollTo(0, parseInt(savedPosition, 10));
      }
    });

    // Salvar posição antes de sair da página
    window.addEventListener('beforeunload', () => {
      localStorage.setItem(scrollKey, window.scrollY);
    });

  // Lista básica de identificadores comuns de Smart TVs
  const tvKeywords = ["SMART-TV", "SmartTV", "HbbTV", "NetCast", "Tizen", "Web0S", "PhilipsTV", "SonyTV", "SmartHub"];

  const isSmartTV = tvKeywords.some(keyword => navigator.userAgent.includes(keyword));

  if (isSmartTV) {
    window.location.href = "/tv.html";
  }
  <script>
  
  <script>
// ID.js - controle básico de tráfego suspeito
const maxRequests = 10; // limite de requisições
const users = {}; // armazena contagem de requisições por ID

function checkRequest(userID) {
    if(!users[userID]) {
        users[userID] = {count: 1, blocked: false};
    } else {
        users[userID].count++;
    }

    if(users[userID].count > maxRequests) {
        users[userID].blocked = true;
        console.warn(`Usuário ${userID} bloqueado (tráfego suspeito)`);
        // Coloca na "fila" simulada
        addToQueue(userID);
    }
}

const queue = [];

function addToQueue(userID) {
    queue.push(userID);
    // Aqui você pode criar lógica para liberar devagar ou monitorar
    console.log(`Usuário ${userID} adicionado à fila. Posição: ${queue.length}`);
}

// Exemplo de requisição
function simulateRequest(userID) {
    if(users[userID]?.blocked) {
        console.log(`Usuário ${userID} está bloqueado, aguardando na fila`);
        return;
    }
    checkRequest(userID);
    console.log(`Requisição do usuário ${userID} processada`);
}

// Teste
simulateRequest("tor_user_1");
simulateRequest("tor_user_1");
// repetir várias vezes para simular bloqueio

<script>
(function autoSavePageState() {
  // Configurações
  const DB_NAME = 'paginaAutoSave';
  const STORE_NAME = 'estados';
  const SAVE_DELAY = 300; // debounce (opcional, para não salvar a cada tecla)

  // Gera uma chave única para a página atual (ex: /contato, /dashboard)
  const paginaChave = window.location.pathname + window.location.search;

  let salvarTimeout;

  // Função para coletar o estado de TODOS os elementos editáveis
  function coletarEstado() {
    const estado = {};

    // 1. Campos de formulário
    document.querySelectorAll('input, textarea, select').forEach(el => {
      if (!el.name && !el.id) return; // opcional: só salva se tiver identificador
      const key = el.name || el.id;
      if (el.type === 'checkbox' || el.type === 'radio') {
        estado[key] = el.checked;
      } else {
        estado[key] = el.value;
      }
    });
  <script>

    <script>
        // Função utilitária para exibir mensagens (substitui alert())
        function showModal(title, message, isError = true) {
            const container = document.getElementById('modal-container');
            document.getElementById('modal-title').textContent = title;
            document.getElementById('modal-message').textContent = message;
            
            const titleElement = document.getElementById('modal-title');
            titleElement.classList.remove('text-red-400', 'text-green-400', 'text-yellow-400');
            if (isError) {
                titleElement.classList.add('text-red-400');
            } else if (title.includes("Sucesso") || title.includes("OK")) {
                titleElement.classList.add('text-green-400');
            } else {
                 titleElement.classList.add('text-yellow-400');
            }

            container.classList.remove('hidden');
        }

        function closeModal() {
            document.getElementById('modal-container').classList.add('hidden');
        }

        // --- SISTEMA DE SEGURANÇA (Funções Requeridas) ---
        
        class SecuritySystem {
            constructor() {
                this.isUserBlocked = false;
                this.sessionActive = false;
                this.lastActivity = 0; // Timestamp da última atividade
                this.sessionTimeoutMs = 15000; // Sessão expira após 15 segundos de inatividade
                this.actionTimestamps = {}; // { 'action_name': [t1, t2, t3, ...] }
                this.rateLimit = 3; // Máximo de 3 ações
                this.rateLimitWindowMs = 5000; // Em 5 segundos
                this.dangerousResources = ['/api/root_access', '/api/delete_db', '/admin/setup'];
                this.maxFileSize = 10 * 1024 * 1024; // 10MB
                this.allowedMimeTypes = ['image/png', 'image/jpeg', 'application/pdf'];
            }

            // [1] Conexão Totalmente Ativa (Gestão de Sessão)
            initSession() {
                this.sessionActive = true;
                this.updateActivity();
                this.sessionInterval = setInterval(() => this.checkSession(), 1000);
                this.updateUI();
                showModal("Sessão Ativa", "Sessão iniciada e monitorada em tempo integral (conexão ativa).", false);
            }

            updateActivity() {
                this.lastActivity = Date.now();
                if (!this.sessionActive) {
                    this.sessionActive = true;
                    this.updateUI();
                }
            }

            checkSession() {
                if (!this.sessionActive) return;

                const timeSinceLastActivity = Date.now() - this.lastActivity;
                
                if (timeSinceLastActivity > this.sessionTimeoutMs) {
                    this.sessionActive = false;
                    clearInterval(this.sessionInterval);
                    this.updateUI();
                    showModal("Sessão Expirada", "A sessão expirou por inatividade. É necessário reautenticar.", true);
                } else {
                    // Mantém a UI atualizada com o status ativo
                    this.updateUI(); 
                }
            }

            // [3] Impedir que o usuário veja várias situações muitas vezes (Rate Limiting)
            checkRateLimit(action) {
                this.updateActivity();
                if (this.isUserBlocked) {
                    this.updateOutput('rate-limit-output', 'Usuário bloqueado. Ação negada.', 'text-red-400');
                    return false;
                }

                const now = Date.now();
                // Inicializa o array de timestamps para a ação, se necessário
                if (!this.actionTimestamps[action]) {
                    this.actionTimestamps[action] = [];
                }

                const timestamps = this.actionTimestamps[action];
                
                // Remove timestamps antigos (fora da janela)
                this.actionTimestamps[action] = timestamps.filter(t => now - t < this.rateLimitWindowMs);

                if (this.actionTimestamps[action].length >= this.rateLimit) {
                    this.updateOutput('rate-limit-output', 
                        `ERRO: Limite de taxa excedido para a ação '${action}'. Tente novamente em alguns segundos.`, 
                        'text-red-400');
                    return false;
                }
                
                // Adiciona o novo timestamp e permite a ação
                this.actionTimestamps[action].push(now);
                this.updateOutput('rate-limit-output', 
                    `Ação '${action}' executada com sucesso. Tentativas restantes na janela: ${this.rateLimit - this.actionTimestamps[action].length}`, 
                    'text-green-400');
                return true;
            }

            triggerAction(action) {
                if (this.sessionActive && this.checkRateLimit(action)) {
                    console.log(`Ação segura: ${action}`);
                }
            }
            
            // [4] Bloquear usuário automaticamente + Tá tentando acessar recursos perigosos
            handleDangerousAccess(resource) {
                this.updateActivity();
                if (this.isUserBlocked) {
                    this.updateOutput('dangerous-access-output', 
                        `Acesso negado. Usuário já bloqueado por tentativa anterior de acesso perigoso.`, 
                        'text-red-400');
                    showModal("Acesso Bloqueado", "O usuário está bloqueado e não pode acessar recursos.", true);
                    return;
                }
                
                if (this.dangerousResources.includes(resource)) {
                    this.isUserBlocked = true;
                    this.updateUI();
                    this.updateOutput('dangerous-access-output', 
                        `ALARME! Tentativa de acesso ao recurso perigoso: ${resource}. Usuário Bloqueado Automaticamente!`, 
                        'text-red-500');
                    showModal("BLOQUEADO", `Acesso ao recurso '${resource}' negado. O usuário foi bloqueado por medida de segurança.`, true);
                } else {
                    this.updateOutput('dangerous-access-output', 
                        `Acesso ao recurso seguro '${resource}' permitido.`, 
                        'text-green-400');
                }
            }
            
            unblockUser() {
                this.isUserBlocked = false;
                this.updateUI();
                this.updateOutput('dangerous-access-output', 
                        `Usuário desbloqueado manualmente.`, 
                        'text-yellow-400');
                showModal("Desbloqueado", "O bloqueio do usuário foi removido.", false);
            }

            // [2] Cache Obrigatório
            manageCache(key, data = null) {
                const cacheKey = `security_cache_${key}`;
                
                if (data !== null) {
                    // Escrever (Cache obrigatório: write)
                    try {
                        localStorage.setItem(cacheKey, JSON.stringify({ data: data, timestamp: Date.now() }));
                        return true;
                    } catch (e) {
                        console.error("Erro ao salvar no localStorage (Cache Obrigatório):", e);
                        return false;
                    }
                } else {
                    // Ler (Cache obrigatório: read)
                    const item = localStorage.getItem(cacheKey);
                    if (item) {
                        try {
                            const cached = JSON.parse(item);
                            // Verificação de validade de cache (ex: 1 hora) pode ser adicionada aqui
                            return cached.data;
                        } catch (e) {
                            console.error("Erro ao analisar dados do cache:", e);
                            localStorage.removeItem(cacheKey); // Limpa cache corrompido
                            return null;
                        }
                    }
                    return null;
                }
            }
            
            testCache() {
                const testKey = 'user_data';
                const mockData = { id: 123, role: 'user' };

                // 1. Tentar ler (deve ser nulo/primeiro acesso)
                let data = this.manageCache(testKey);
                
                if (data === null) {
                    // 2. Escrever (Obrigatório)
                    this.manageCache(testKey, mockData);
                    this.updateOutput('cache-output', 
                        `Cache vazio. Dados mockados escritos no cache obrigatório: ${JSON.stringify(mockData)}`,
                        'text-green-400');
                } else {
                    // 3. Ler novamente
                    this.updateOutput('cache-output', 
                        `Dados recuperados do cache obrigatório: ${JSON.stringify(data)}`,
                        'text-yellow-400');
                }
            }
            
            // [5] Verificar qualquer arquivo e sendo enviado
            validateFile(file) {
                this.updateActivity();
                if (this.isUserBlocked) {
                    this.updateOutput('file-output', 'Usuário bloqueado. Envio de arquivo negado.', 'text-red-400');
                    return false;
                }
                
                let validationResult = { valid: true, message: "Arquivo válido." };

                if (file.size > this.maxFileSize) {
                    validationResult.valid = false;
                    validationResult.message = `Erro de tamanho: ${file.name} tem ${(file.size / 1024 / 1024).toFixed(2)}MB, excede o limite de ${this.maxFileSize / 1024 / 1024}MB.`;
                }

                if (!this.allowedMimeTypes.includes(file.type)) {
                    validationResult.valid = false;
                    validationResult.message = validationResult.message.includes("Erro") 
                        ? `${validationResult.message} | Erro de tipo: Tipo '${file.type}' não permitido.` 
                        : `Erro de tipo: Tipo '${file.type}' não permitido. Tipos aceitos: ${this.allowedMimeTypes.join(', ')}.`;
                }

                return validationResult;
            }

            testFileValidation(mockFile) {
                const result = this.validateFile(mockFile);
                if (result.valid) {
                     this.updateOutput('file-output', `[OK] ${mockFile.name}: ${result.message}`, 'text-green-400');
                     showModal("Validação OK", `Arquivo '${mockFile.name}' foi aprovado.`, false);
                } else {
                    this.updateOutput('file-output', `[FALHA] ${result.message}`, 'text-red-400');
                    showModal("Validação de Arquivo Negada", result.message, true);
                }
            }

            // --- UI/DISPLAY FUNCTIONS ---

            updateUI() {
                const sessionText = document.getElementById('session-text');
                const sessionIndicator = document.getElementById('session-indicator');
                const blockText = document.getElementById('block-text');
                const blockIndicator = document.getElementById('block-indicator');
                const unblockBtn = document.getElementById('unblock-btn');

                // Status de Sessão
                if (this.sessionActive) {
                    sessionText.textContent = 'ATIVO (Totalmente Conectado)';
                    sessionText.classList.remove('text-red-400');
                    sessionText.classList.add('text-green-400');
                    sessionIndicator.classList.remove('bg-red-500', 'bg-yellow-500');
                    sessionIndicator.classList.add('bg-green-500');
                } else {
                    sessionText.textContent = 'INATIVO / EXPIRADO';
                    sessionText.classList.remove('text-green-400');
                    sessionText.classList.add('text-red-400');
                    sessionIndicator.classList.remove('bg-green-500', 'bg-yellow-500');
                    sessionIndicator.classList.add('bg-red-500');
                }

                // Status de Bloqueio
                if (this.isUserBlocked) {
                    blockText.textContent = 'BLOQUEADO AUTOMATICAMENTE';
                    blockText.classList.remove('text-green-400', 'text-yellow-400');
                    blockText.classList.add('text-red-500');
                    blockIndicator.classList.remove('bg-green-500', 'bg-yellow-500');
                    blockIndicator.classList.add('bg-red-500');
                    unblockBtn.classList.remove('hidden');
                } else {
                    blockText.textContent = 'Normal';
                    blockText.classList.remove('text-red-500', 'text-yellow-400');
                    blockText.classList.add('text-green-400');
                    blockIndicator.classList.remove('bg-red-500', 'bg-yellow-500');
                    blockIndicator.classList.add('bg-green-500');
                    unblockBtn.classList.add('hidden');
                }
            }
            
            updateOutput(elementId, message, colorClass) {
                const element = document.getElementById(elementId);
                element.textContent = message;
                element.className = element.className.split(' ').filter(c => !c.startsWith('text-')).join(' ');
                element.classList.add(colorClass);
            }
        }
        
        const security = new SecuritySystem();
        
        window.onload = () => {
             // Inicia a simulação da sessão e o monitoramento
             security.initSession(); 
        };
        
    </script>











